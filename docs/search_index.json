[["index.html", "Biostar 前言", " Biostar 小苏 2025-03-31 前言 我不是代码的创作者，我只是代码的搬运工！ "],["aria2.html", "第 1 章 aria2", " 第 1 章 aria2 aria2 是一个轻量级的多协议和多源命令行下载工具。它支持 HTTP/HTTPS、FTP、BitTorrent 和 Metalink。aria2 可以通过最大化网络带宽利用率来加快下载速度。它支持 HTTP/HTTPS 代理，SOCKS 代理，HTTP 代理隧道，NAT 穿透，IPv6 和 IP 版本选择。aria2 可以通过 JSON-RPC 和 XML-RPC 接口进行控制。 官方教程：https://github.com/aria2/aria2 使用示范 URL=https://ftp.ensembl.org/pub/release-113/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.toplevel.fa.gz make -f src/run/aria.mk URL=${URL} run aria.mk "],["curl.html", "第 2 章 curl", " 第 2 章 curl curl 是一个命令行工具和库，用于传输数据，支持多种协议，包括 HTTP、HTTPS、FTP、FTPS、SFTP、IMAP、SMTP、POP3、LDAP、RTMP 和 RTSP。curl 还支持 SSL 证书、HTTP POST、HTTP PUT、FTP 上传、HTTP 基本身份验证、代理、cookie、用户代理、压缩、断点续传、文件传输限速、重定向等功能。 使用示范: URL=https://ftp.ensembl.org/pub/release-113/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.toplevel.fa.gz make -f src/run/curl.mk URL=${URL} run aria.mk "],["sra.html", "第 3 章 SRA", " 第 3 章 SRA SRA（Sequence Read Archive） 是一个由美国国家生物技术信息中心（NCBI）维护的高通量测序数据公共仓库。它是国际核苷酸序列数据库合作（INSDC）的组成部分，与欧洲生物信息研究所（EBI）和日本DNA数据库（DDBJ）共享数据。从数据库中下载原始测序数据是必备技能。 使用示范: 1. 使用 fastq-dump 工具。 SRR=SRR12351448 make -f src/run/sra.mk SRR=${SRR} N=ALL run design=design.csv cat ${design} | parallel -v --eta --lb --header : --colsep , \\ make -f src/run/sra.mk \\ SRR={Run} \\ N=ALL \\ run 使用 aria2 工具。 SRR=SRR12351448 make -f src/run/sra.mk SRR=${SRR} N=ALL aria design=design.csv cat ${design} | parallel -v --eta --lb --header : --colsep , \\ make -f src/run/sra.mk \\ SRR={Run} \\ N=ALL \\ aria sra.mk "],["fastp.html", "第 4 章 fastp", " 第 4 章 fastp 官方教程：https://github.com/OpenGene/fastp 使用示范: 单端数据 SRR=SRR12351448 DATA=data READS=${DATA}/reads make -f src/run/fastp.mk P1=${READS}/${SRR}_1.fastq run DATA=data READS=${DATA}/reads design=${DATA}/design.csv cat ${design} | parallel --header : --colsep , \\ make -f src/run/fastp.mk \\ P1=${READS}/{Run}_1.fastq \\ run 双端数据 SRR=SRR12351448 DATA=data READS=${DATA}/reads make -f src/run/fastp.mk P1=${READS}/${SRR}_1.fastq P2=${READS}/${SRR}_2.fastq run DATA=data READS=${DATA}/reads design=${DATA}/design.csv cat ${design} | parallel --header : --colsep , \\ make -f src/run/fastp.mk \\ P1=${READS}/{Run}_1.fastq \\ P2=${READS}/{Run}_2.fastq \\ run sra.mk "],["bwa.html", "第 5 章 bwa 5.1 构建索引 5.2 比对", " 第 5 章 bwa 官方教程：https://github.com/lh3/bwa 5.1 构建索引 REF=~/database/Human/Homo_sapiens.GRCh38.dna.toplevel.fa make -f ~/src/run/bwa.mk REF=${REF} index 5.2 比对 单端数据 DATA=data REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa BWA=results/bwa CLEANDATA=${DATA}/reads Run=SRR1343245 make -f src/run/bwa.mk \\ REF=${REF} \\ R1=${CLEANDATA}/${Run}_1.trimmed.fastq \\ BAM=${BWA}/{sample}.bam \\ run DATA=data design=${DATA}/design.csv REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa CLEANDATA=${DATA}/reads BWA=results/bwa cat ${design} | parallel --header : --colsep , \\ make -f src/run/bwa.mk \\ REF=${REF} \\ R1=${CLEANDATA}/{Run}_1.trimmed.fastq \\ BAM=${BWA}/{sample}.bam \\ run 双端数据 DATA=data REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa BWA=results/bwa CLEANDATA=${DATA}/reads Run=SRR1343245 make -f src/run/bwa.mk \\ REF=${REF} \\ R1=${CLEANDATA}/${Run}_1.trimmed.fastq \\ R2=${CLEANDATA}/${Run}_2.trimmed.fastq BAM=${BWA}/{sample}.bam \\ run DATA=data design=${DATA}/design.csv REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa CLEANDATA=${DATA}/reads BWA=results/bwa cat ${design} | parallel --header : --colsep , \\ make -f src/run/bwa.mk \\ REF=${REF} \\ R1=${CLEANDATA}/{Run}_1.trimmed.fastq \\ R2=${CLEANDATA}/{Run}_2.trimmed.fastq \\ BAM=${BWA}/{sample}.bam \\ run sra.mk "],["hisat2.html", "第 6 章 hisat2 6.1 构建索引 6.2 比对", " 第 6 章 hisat2 官方教程：https://daehwankimlab.github.io/hisat2/ 6.1 构建索引 REF=~/database/Human/Homo_sapiens.GRCh38.dna.toplevel.fa make -f ~/src/run/hisat2.mk REF=${REF} index 6.2 比对 单端数据 DATA=data REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa HISAT2=results/hisat2 CLEANDATA=${DATA}/reads Run=SRR1343245 make -f src/run/hisat2.mk \\ REF=${REF} \\ R1=${CLEANDATA}/${Run}_1.trimmed.fastq \\ BAM=${HISAT2}/{sample}.bam \\ run DATA=data design=${DATA}/design.csv REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa CLEANDATA=${DATA}/reads HISAT2=results/hisat2 cat ${design} | parallel --header : --colsep , \\ make -f src/run/hisat2.mk \\ REF=${REF} \\ R1=${CLEANDATA}/{Run}_1.trimmed.fastq \\ BAM=${HISAT2}/{sample}.bam \\ run 双端数据 DATA=data REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa HISAT2=results/hisat2 CLEANDATA=${DATA}/reads Run=SRR1343245 make -f src/run/hisat2.mk \\ REF=${REF} \\ R1=${CLEANDATA}/${Run}_1.trimmed.fastq \\ R2=${CLEANDATA}/${Run}_2.trimmed.fastq BAM=${HISAT2}/{sample}.bam \\ run DATA=data design=${DATA}/design.csv REF=genome/Human/Homo_sapiens.GRCh38.dna.primary_assembly.fa CLEANDATA=${DATA}/reads HISAT2=results/hisat2 cat ${design} | parallel --header : --colsep , \\ make -f src/run/hisat2.mk \\ REF=${REF} \\ R1=${CLEANDATA}/{Run}_1.trimmed.fastq \\ R2=${CLEANDATA}/{Run}_2.trimmed.fastq \\ BAM=${HISAT2}/{sample}.bam \\ run sra.mk "],["makefile.html", "第 7 章 makefile 7.1 简介 7.2 makefile 的小技巧 7.3 生信流程模块化 7.4 拓展", " 第 7 章 makefile 7.1 简介 官方教程： https://www.gnu.org/software/make/manual/make.html 在生信上游分析中，我们不可能每次都手动输入我们的命令，通常我们会将我们的命令写入到一个脚本文件中，然后通过运行脚本文件来执行我们的命令。但是，当我们工作有些变化时，我们就需要做出一些改变，包括增加或删除，这样就会增加我们的工作量和代码复用性。因此，我们可以使用 makefile 来模块化我们的分析流程。 Makefile 是一种用于自动化构建过程的文件，通常用于 Unix 和类 Unix 系统上。它由一个名为 make 的工具读取和执行。Makefile 定义了一系列的规则和依赖关系，用于指导如何编译和链接程序。 在生信分析中使用 makefile 可以帮助我们自动化分析流程，我们不需要特别高级的学习。 下面是一个简单的 makefile 示例： 首先我们创建一个文件，命名为Makefile，然后在文件中写入一些内容。 .RECIPEPREFIX = &gt; # 命令 1 foo: &gt; echo Hello world! # 命令 2 bar: &gt; echo Hello world! &gt; echo Hello Everyone! 在这个 makefile 中，我们定义了两个目标 foo 和 bar，分别对应两个命令。我们可以通过 make foo 和 make bar 来执行这两个命令。 $ make -f Makefile foo echo Hello world! Hello world! $ make -f Makefile bar echo Hello world! Hello world! echo Hello Everyone! Hello Everyone! 当你的文件名是 Makefile 时，你可以直接使用 make 命令，而不需要 -f 参数。 通常 makefile 会将命令和结果同时输出到终端，如果我们只想输出结果，可以将命令前加一个@符号。比如这样： .RECIPEPREFIX = &gt; # 命令 1 foo: &gt; @echo Hello world! 和 bash 脚本一样，makefile 也可以使用变量，比如： .RECIPEPREFIX = &gt; NAME = xiaoming hello: &gt; @echo Hello ${NAME} 输出结果为： $ make -f anyfile hello Hello xiaoming make 的开发目的是跟踪目标之间的相互依赖关系，并在任何文件发生更改时，仅执行必要的步骤。例如，如果你已经有一个基因组索引，make 命令将跳过索引步骤。 # Set the prefix from tabs to &gt; .RECIPEPREFIX = &gt; counts.txt: &gt; echo 100 &gt; counts.txt names.txt: &gt; echo Joe &gt; names.txt results.txt: counts.txt names.txt &gt; cat counts.txt names.txt &gt; results.txt 在上面的 Makefile 中，输入 make results.txt 将首先生成 counts.txt 和 names.txt，如果它们不存在的话。然后，它将从这两个文件生成 results.txt。如果你再次运行 make，它将不会执行任何操作，因为所有文件已经存在。 7.2 makefile 的小技巧 7.2.1 默认设置 在 Makefile 中添加上这些设置后可以让 makefile 更加强大： .RECIPEPREFIX = &gt; .DELETE_ON_ERROR: SHELL := bash .ONESHELL: .SHELLFLAGS := -eu -o pipefail -c MAKEFLAGS += --warn-undefined-variables --no-print-directory .DELETE_ON_ERROR: 这个特殊目标告诉 make 在命令执行失败时删除生成的目标文件，以防止生成不完整或损坏的文件。 SHELL := bash 这行代码指定 make 使用 bash 作为默认的 shell 来执行命令。默认情况下，make 使用 /bin/sh，但可以通过这种方式指定使用其他 shell。 .ONESHELL: 这个特殊目标指示 make 将单个目标的所有命令在同一个 shell 会话中执行，而不是为每个命令启动一个新的 shell。这对于需要在多个命令之间共享环境或状态的情况很有用。 .SHELLFLAGS := -eu -o pipefail -c 这些标志用于配置 bash 的行为： -e：如果任何命令失败（返回非零状态），则 bash 退出。 -u：使用未定义的变量时，bash 会报错并退出。 -o pipefail：如果管道中的任何命令失败，整个管道返回失败状态。 -c：从字符串中读取命令并执行。 MAKEFLAGS += --warn-undefined-variables --no-print-directory --warn-undefined-variables：警告使用未定义的变量，以帮助捕获拼写错误或遗漏的变量定义。 --no-print-directory：禁用 make 在递归调用时打印目录信息，这可以使输出更简洁。 7.2.2 “试运行”模式 在 bash 命令中，命令对不对，我们可以运行一下看看，如果不对，我们可以再次运行。但是在 makefile 中，我们不希望这样，我们希望一次就对，所以我们可以使用 -n 参数来进行“试运行”模式。这样 makefile 会输出将要执行的命令，但是不会真正执行。这样可以帮助我们检查命令是否正确。 $ make hello Hello xiaoming $ make hello -n echo Hello xiaoming 7.2.3 变量命名 在 Makefile 中可以通过 ?= 这样的方式预设变量： .RECIPEPREFIX = &gt; NAME ?= xiaoming hello: &gt; @echo Hello ${NAME} 这样，如果我们在命令行中没有定义 NAME 变量，那么 NAME 就会被设置为 xiaoming。 $ make hello Hello xiaoming $ make hello NAME=lihua Hello lihua 7.2.4 文本替换 在某些情况下，您想从现有字符串创建一个新字符串。 例如，你想从路径中提取目录名或文件名，如 PATH = data/reads/abc.txt make 语法提供了函数来执行此操作，例如： DIR = $(dir ${PATH}) 将包含 data/reads/ FNAME = $(notdir ${PATH}) 将包含 abc.txt # Sets the prefix for commands. .RECIPEPREFIX = &gt; # Set a filename FILE = data/refs/ebola.fa.gz demo: # Prints: data/refs/ebola.fa.gz &gt; @echo ${FILE} # Prints: data/refs &gt; @ echo $(dir ${FILE}) # Prints: ebola.fa.gz &gt; @ echo $(notdir ${FILE}) # Prints: data/refs/human.fa.gz &gt; @ echo $(subst ebola,human,${FILE}) # Prints: data/refs/ebola.fa &gt; @echo $(patsubst %.gz,%,${FILE}) $ make demo data/refs/ebola.fa.gz data/refs/ ebola.fa.gz data/refs/human.fa.gz data/refs/ebola.fa 7.3 生信流程模块化 虽然我们都希望一个脚本能够完成所有的工作，这样是可实现的，但可能会遇到各种各样的问题，比如脚本过长，不易维护，不易复用等。因此，我们可以将脚本分解为多个模块，每个模块负责一个特定的任务。这样可以提高代码的可读性，可维护性和可复用性。 明白了需求后，按照一个良好的编写习惯，可以很好的将脚本模块化。这样可以提高代码的可读性，可维护性和可复用性。我们接下来编写一个从 SRA 数据库下载 metadata 数据的 make 脚本吧。 7.3.1 step1: 默认设置 # Makefile customizations. .RECIPEPREFIX = &gt; .DELETE_ON_ERROR: SHELL := bash .ONESHELL: .SHELLFLAGS := -eu -o pipefail -c MAKEFLAGS += --warn-undefined-variables --no-print-directory 7.3.2 step2: 打印帮助 我们总是会忘记自己的脚本是干什么的。因此，最好第一个命令是打印帮助。 # Print usage information. usage: &gt; @echo &quot;#&quot; &gt; @echo &quot;# metadata.mk: downloads metadata from SRA&quot; &gt; @echo &quot;#&quot; &gt; @echo &quot;# SRA=${SRA}&quot; &gt; @echo &quot;#&quot; &gt; @echo &quot;# make run|keys|clean&quot; &gt; @echo &quot;#&quot; 7.3.3 step3: 定义变量 刚开始可以不需要这一步，等到足够熟练使用后，可以将一些常用的变量定义在这里。 # Sets the default target. SRA ?= PRJEB31790 7.3.4 step4: 添加代码 这里添加一下下载，提取信息，清理的代码。 run: &gt; @bio search ${SRA} -H --csv --all &gt; ${SRA}.csv keys: ${SRA}.csv &gt; @cat ${SRA}.csv | csvcut -c run_accession,sample_title clean: &gt; @rm -f ${SRA}.csv 7.3.5 step5: 运行命令 把上述所有代码放到一个文件中，然后运行 make 命令。 # 使用默认变量 make -f metadata.mk run # 使用自定义变量 make -f metadata.mk run SRA=PRJNA932187 # 提取关键信息 make -f metadata.mk keys # 也可以直接运行，因为定义了依赖，会默认先运行 run，然后运行 keys # 清理 make -f metadata.mk clean 7.4 拓展 我经常使用的软件 bio : https://www.bioinfo.help/index.html 这个软件有很多我们常用的生信工具。我建议你使用它！ 下载软件后，运行下面这个代码会下载很多的 makefile 脚本，熟悉使用它们，你会发现生信分析变得更加简单。 bio code "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
